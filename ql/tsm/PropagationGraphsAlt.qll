/**
 * An implementation of triples in propagation graphs with additional filtering.
 */
import javascript
import PropagationGraphs

predicate repGenerator = candidateRep/3;

int maxReprPerSink() { result = 5 }

module PropagationGraph {
  import CanonicalReps

  string candidateRep(DataFlow::Node nd, boolean asRhs) { result = candidateRep(nd, _, asRhs) }

  /**
   * Holds if `source` has a candidate representation, and is a known source according to
   * `KnownRepr`.
   */
  predicate isKnownSource(DataFlow::Node source) {
    exists(string repr |
      repr = any(KnownRepr k).getRepr("sources") and
      repr = candidateRep(source, false)
    )
  }

  /**
   * Holds if `sink` has a candidate representation, and is a known sink according to `KnownRepr`.
   */
  predicate isKnownSink(DataFlow::Node sink) {
    exists(string repr |
      repr = any(KnownRepr k).getRepr("sinks") and
      repr = candidateRep(sink, true)
    )
  }

  /**
   * Holds if `sanitizer` has a candidate representation, and is a known sanitizer according to
   * `KnownRepr`.
   */
  predicate isKnownSanitizer(DataFlow::Node sanitizer) {
    exists(string repr |
      repr = any(KnownRepr k).getRepr("sanitizers") and
      repr = candidateRep(sanitizer, false)
    )
  }

  /**
   * A set of known sources, sinks, or sanitizers.
   *
   * Subclasses of this class are generated by the `code/compute_metrics.py` script.
   */
  abstract class KnownRepr extends string {
    bindingset[this]
    KnownRepr() { any() }

    /**
     * Gets a representation of a source, sink, or sanitizer in this set, depending on `t`:
     * `sources` gets a source representation, `sanitizers` a sanitizer representation, and
     * `sinks` a sink representation.
     */
    abstract string getRepr(string t);
  }

  /**
   * A query-specific filter that a triple of candidate sources, sinks, and sanitizers must satisfy.
   *
   * Subclasses of this class are defined in `ql/tsm/<query>/PropagationGraph-<query>.ql`.
   */
  abstract class NodeFilter extends string {
    bindingset[this]
    NodeFilter() { any() }

    /** Holds if this filters accepts `src` as a candidate source. */
    predicate filterSource(DataFlow::Node src) { any() }

    /** Holds if this filter accepts `san` as a candidate sanitizer. */
    predicate filterSanitizer(DataFlow::Node san) { any() }

    /** Holds if this filter accepts `snk` as a candidate sink. */
    predicate filterSink(DataFlow::Node snk) { any() }
  }

  /**
   * Holds if `(src, san, snk)` is a triple, and it is acceptable according to some `NodeFilter`.
   */
  predicate tripleSrcSanSnk(DataFlow::Node src, DataFlow::Node san, DataFlow::Node snk) {
    triple(src, san, snk) and
    applyFilter(src, san, snk)
  }

  /** Holds if `(src, san, snk)` would be an acceptable triple according to some `NodeFilter`. */
  pragma[inline]
  predicate applyFilter(DataFlow::Node src, DataFlow::Node san, DataFlow::Node snk) {
    exists(NodeFilter f |
      f.filterSource(src) and
      f.filterSanitizer(san) and
      f.filterSink(snk)
    )
  }

  /**
   * Holds if there is a triple `(ssrc, ssan, ssnk)` that is acceptable according to some.
   * `NodeFilter`.
   */
  predicate pairSanSnk(string ssan, string ssnk) {
    exists(DataFlow::Node src, DataFlow::Node san, DataFlow::Node snk |
      san = reachableFromSourceCandidate(src, DataFlow::TypeTracker::end()) and
      src.getEnclosingExpr() != san.getEnclosingExpr() and
      snk = reachableFromSanitizerCandidate(san, DataFlow::TypeTracker::end()) and
      isSinkCandidate(snk) and
      exists(getconcatrep(src, false)) and
      ssan = getconcatrep(san, false) and
      ssnk = getconcatrep(snk, true) and
      applyFilter(src, san, snk)
    )
  }

  /**
   * Holds if there is a triple `(ssrc, ssan, ssnk)` that is acceptable according to some.
   * `NodeFilter`.
   */
  predicate pairSrcSan(string ssrc, string ssan) {
    exists(DataFlow::Node src, DataFlow::Node san, DataFlow::Node snk |
      san = reachableFromSourceCandidate(src, DataFlow::TypeTracker::end()) and
      src.getEnclosingExpr() != san.getEnclosingExpr() and
      snk = reachableFromSanitizerCandidate(san, DataFlow::TypeTracker::end()) and
      isSinkCandidate(snk) and
      exists(getconcatrep(snk, true)) and
      ssan = getconcatrep(san, false) and
      ssrc = getconcatrep(src, false) and
      applyFilter(src, san, snk)
    )
  }

  /**
   * Gets all the best representations for `n` that occur more than `minOccurrences()`,
   * concatenated with `::`.
   */
  string getconcatrep(DataFlow::Node n, boolean asRhs) {
    result =
      strictconcat(string r |
        r = chooseBestRep(n, asRhs) and
        count(DataFlow::Node nd2 | r = repGenerator(nd2, _, asRhs)) >= minOccurrences()
      |
        r, "::"
      )
  }
}
